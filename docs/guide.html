<html>
<body>

<h1 id="guide">Руководство по языку #Ф</h1>
<h2 id="about">О языке</h2>
<p>В языке программирования #Ф реализованы следующие базовые функции, необходимые для работы - именованные переменные, рекурсия, ленивые вычисления, функции.</p>
<p>Подробнее о возможностях языка ниже.</p>
<h2 id="inside">Как и почему оно работает</h2>
<p>Наш язык интерпретируемый. Сам процесс исполнения программы состоит из 3 этапов: парсинг программы и её токенизация, построение синтаксического дерева программы и интерпретация.</p>
<p>Подробнее про синтаксис языка будет далее.</p>
<h3 id="parser">Парсер</h3>
<p>Парсер берёт текст программы и превращает его в последовательность токенов тем самым убирая все ненужные символы, оставляя только важную для программы информацию. На выходе он оставляет список токенов, каждый из которых является либо числом, либо командой, либо символами табуляции и новой строки.</p>
<p>Всего существует несколько типов лексем: операторы, слова идентификаторы, команды языка, и вспомогательные символы (скобки, табуляция, пробел, новая строка). Парсер последовательно читает текст программы символ за символом и в зависимости от прочитанного символа читает всю лексему. Например, если парсер считал число, то далее он будет ожидать на вход числа или пробел. В противном случае программа завершится с ошибкой.</p>
<p>Некоторые токены с их расшифровкой:</p>
<table style="height: 217px; width: 404px;">
<tbody>
<tr>
<td style="width: 106px;">Токен</td>
<td style="width: 186.388px;">Описание</td>
<td style="width: 91.6125px;">Пример</td>
</tr>
<tr>
<td style="width: 106px;">Number</td>
<td style="width: 186.388px;">Вещественное число</td>
<td style="width: 91.6125px;">5</td>
</tr>
<tr>
<td style="width: 106px;">Strings</td>
<td style="width: 186.388px;">Строка (значение)</td>
<td style="width: 91.6125px;">"aboba"</td>
</tr>
<tr>
<td style="width: 106px;">Operator</td>
<td style="width: 186.388px;">Операция</td>
<td style="width: 91.6125px;">+</td>
</tr>
<tr>
<td style="width: 106px;">FunctionDefinition</td>
<td style="width: 186.388px;">Определение новой функции</td>
<td style="width: 91.6125px;">функция</td>
</tr>
<tr>
<td style="width: 106px;">NewVariable</td>
<td style="width: 186.388px;">Определение новой переменной</td>
<td style="width: 91.6125px;">пусть</td>
</tr>
<tr>
<td style="width: 106px;">IfStatement</td>
<td style="width: 186.388px;">Условный оператор</td>
<td style="width: 91.6125px;">если</td>
</tr>
<tr>
<td style="width: 106px;">LeftRoundBracket</td>
<td style="width: 186.388px;">Открывающая круглая скобка</td>
<td style="width: 91.6125px;">(</td>
</tr>
<tr>
<td style="width: 106px;">Comma</td>
<td style="width: 186.388px;">Запятая</td>
<td style="width: 91.6125px;">,</td>
</tr>
<tr>
<td style="width: 106px;">Colon</td>
<td style="width: 186.388px;">двоеточие</td>
<td style="width: 91.6125px;">:</td>
</tr>
<tr>
<td style="width: 106px;">Identifier</td>
<td style="width: 186.388px;">Имя функции или переменной</td>
<td style="width: 91.6125px;">счётчик</td>
</tr>
</tbody>
</table>
<p>На этапе парсинга программы проверяется корректность всех введённых символов и слов.</p>
<h3 id="tree">Синтаксическое дерево</h3>
<p>Далее из последоватльности лексем собирается синтаксическое дерево программы, по которому она будет выполняться. Синтаксическое дерево представляет последовательность команд вместе с их аргументами в виде удобном для выполнения интерпретатором.&nbsp;</p>
<p>При построеннии синтаксического дерево мы линейно проходимся по списку лексем и пытаемся выделить из него отдельные команды, которые затем добавляем в список команд.</p>
<p>Пример некоторых элементов синтаксического дерева:</p>
<table style="height: 276px; width: 436px;">
<tbody>
<tr>
<td style="width: 108.65px;">OrdinaryList</td>
<td style="width: 311.35px;">Лист содержащий либо набор команд, либо набор аргументов</td>
</tr>
<tr>
<td style="width: 108.65px;">FunctionDefinition</td>
<td style="width: 311.35px;">Содержит имя функции, тело функции, количество аргументов функции и их список</td>
</tr>
<tr>
<td style="width: 108.65px;">
<div>
<div>IntroduceVariable</div>
</div>
</td>
<td style="width: 311.35px;">Содержит имя новой переменной и её начальное значение</td>
</tr>
<tr>
<td style="width: 108.65px;">OperatorNode</td>
<td style="width: 311.35px;">Оператор и список его аргументов</td>
</tr>
<tr>
<td style="width: 108.65px;">FuntionCall</td>
<td style="width: 311.35px;">Имя функции и список аргументов для её вызова</td>
</tr>
<tr>
<td style="width: 108.65px;">Condition</td>
<td style="width: 311.35px;">Булевый оператор условия и два списка команд для каждого из значений условия</td>
</tr>
<tr>
<td style="width: 108.65px;">Print</td>
<td style="width: 311.35px;">Список команд которые необходимо напечатать</td>
</tr>
<tr>
<td style="width: 108.65px;">Return</td>
<td style="width: 311.35px;">Список возвращаемых аргументов из функции</td>
</tr>
</tbody>
</table>
<p>На этом этапе проверяется правильность последовательности команд, например, то что функция верно определена. Также проверяется существование вызываемых функция и используемых переменных.</p>
<h3 id="interpreter">Интерпретатор</h3>
<p>Интерпретатор данного языка анализирует структуру синтаксического дерева и в зависимости от типов узлов производит соответствующие вычисления.</p>
<ul>
<li>Каждый раз новая вызванная функция или переменная проверяется на наличие в текущем окружении (было ли ее объявление перед этим вызовом). Если объявления не было, программа завершается с ошибкой</li>
<li>При объявлении переменной её значение не вычисляется сразу, а просто связывается с именем. Вычисление откладывается до того момента, пока эта переменная не потребуется в программе (ленивые вычисления)</li>
<li>При интерпретации условного выражения сначала вычисляется условие, а затем соответствующая этому условию ветвь</li>
<li>При вызове функции проверяется соответствие количества аргументов объявленной и вызываемой функции. Затем аргументы функции связываются с параметрами вызова, и вместе с сохраненным окружением используются для интерпретации тела функции. В этом процессе также учитывается информация о самой функции, что позволяет осуществлять рекурсивные вызовы функций</li>
<li>При выполнении различных выражений с операторами сначала проверяется соответсвие типов операндов. При несоответствии возвращается сообщение об ошибке</li>
<li>Если необходимо интерпретировать тип OrdinaryList, то сначала интерпретируются все его подвыражения</li>
<li>Интерпретатор возращает один из подтипов SyntaxNode</li>
</ul>
<h2 id="variables">Переменные</h2>
<p>Чтобы создать именованную переменную в языке #Ф используется следующая конструкция:</p>
<p><code> пусть {название переменной} = {начальное значение}</code></p>
<p>Переменная не может менять своё значение, которое может быть одним из нескольких типов:</p>
<table style="height: 66px; width: 292.3px;">
<tbody>
<tr>
<td style="width: 98px;">Тип переменной</td>
<td style="width: 179.3px;">Значение</td>
</tr>
<tr>
<td style="width: 98px;">строка</td>
<td style="width: 179.3px;">последовательность символов</td>
</tr>
<tr>
<td style="width: 98px;">число</td>
<td style="width: 179.3px;">дробное число</td>
</tr>
<tr>
<td style="width: 98px;">булевый тип</td>
<td style="width: 179.3px;">истина/ложь</td>
</tr>
</tbody>
</table>
<p>Например программа:</p>
<p><code> пусть а = "Hello world!"<br /> пусть б = 5 <br /> пусть в = истина <br /> выведи а б в</code></p>
<p>Выведет:</p>
<p><code> Hello world! 5.340000 true</code></p>
<h2 id="expression">Выражения</h2>
<p>Для более лёгкого парсинга было принято решение сделать все операторы префиксными, то есть сначала должен стоять оператор, а за ним все его аргументы. Аргументами выражения могут быть как число, булевый тип, вызов функции, переменная, так и другое выражение.</p>
<p>При использовании логических и арифметических&nbsp;операторов, они должны быть выделены скобками.</p>
<p>Таблица типов операторов:</p>
<table style="height: 110px;" width="510">
<tbody>
<tr style="height: 27px;">
<td style="width: 134.637px; height: 27px;">Операторы</td>
<td style="width: 112.65px; height: 27px;">Тип аргументов</td>
<td style="width: 112.65px; height: 27px;">Количество аргументов</td>
<td style="width: 126.062px; height: 27px;">Возвращаемое значение</td>
</tr>
<tr style="height: 13px;">
<td style="width: 134.637px; height: 13px;">+, -, *, /</td>
<td style="width: 112.65px; height: 13px;">Число</td>
<td style="width: 112.65px; height: 13px;">2</td>
<td style="width: 126.062px; height: 13px;">Число</td>
</tr>
<tr style="height: 13px;">
<td style="width: 134.637px; height: 13px;">!</td>
<td style="width: 112.65px; height: 13px;">Булевый</td>
<td style="width: 112.65px; height: 13px;">1</td>
<td style="width: 126.062px; height: 13px;">Булевый</td>
</tr>
<tr style="height: 13.6625px;">
<td style="width: 134.637px; height: 13.6625px;">&amp;, |</td>
<td style="width: 112.65px; height: 13.6625px;">Булевый</td>
<td style="width: 112.65px; height: 13.6625px;">2</td>
<td style="width: 126.062px; height: 13.6625px;">Булевый</td>
</tr>
<tr style="height: 13px;">
<td style="width: 134.637px; height: 13px;">=</td>
<td style="width: 112.65px; height: 13px;">Булевый или число</td>
<td style="width: 112.65px; height: 13px;">2</td>
<td style="width: 126.062px; height: 13px;">Булевый</td>
</tr>
<tr style="height: 13px;">
<td style="width: 134.637px; height: 13px;">&gt;, &lt;</td>
<td style="width: 112.65px; height: 13px;">Число</td>
<td style="width: 112.65px; height: 13px;">2</td>
<td style="width: 126.062px; height: 13px;">Булевый</td>
</tr>
</tbody>
</table>
<p>Пример, программа:</p>
<p><code>выведи (&lt; 2 5) # 2 &lt; 5 <br /> выведи (= истина ложь) # true == false<br /> выведи (+ (* 2 5) 4) # 2 * 5 + 4<br /> <br /> пусть а = 50<br /> выведи (- а (+ 40 2)) # a - (40 + 2)<br /> <br /> выведи (= (! ложь) (| истина ложь)) # !false == (true || false)</code></p>
<p>Выведет:</p>
<p><code> true false 14.000000 8.000000 true</code></p>
<h2 id="condition">Условный оператор</h2>
<p>Условный оператор объявляется с помощью ключевых слов "если", "тогда", "иначе" и выглядит следующим образом:</p>
<p><code>если ({оператор условия})<br /> &nbsp;&nbsp;&nbsp;&nbsp;тогда:<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{действия если условие истино}<br /> &nbsp;&nbsp;&nbsp;&nbsp;иначе:<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{действия если условие ложно}<br /></code></p>
<p>Все блоки кода выделяются табуляцией как показано в примере. Блока "иначе" может не быть, тогда оператор будет выглядеть вот так:</p>
<p><code>если ({оператор условия})<br /> &nbsp;&nbsp;&nbsp;&nbsp;тогда:<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{действия если условие истино}<br /></code></p>
<p>Оператор условия должен возвращать значение true или false. Пример, программы с условным оператором:</p>
<p><code>пусть a = 50<br /> пусть б = 100<br /> <br /> если (&gt; a 40)<br /> &nbsp;&nbsp;&nbsp;&nbsp;тогда:<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;выведи "a &gt; 40 "<br /> <br /> если (&gt; a б)<br /> &nbsp;&nbsp;&nbsp;&nbsp;тогда:<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;выведи "a &gt; б "<br /> &nbsp;&nbsp;&nbsp;&nbsp;иначе:<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;выведи "a &lt;= б "<br /> выведи "{действие после условия}"<br /> <br /> если (!истина)<br /> &nbsp;&nbsp;&nbsp;&nbsp;тогда:<br /> &nbsp;&nbsp;&nbsp;&nbsp;иначе:<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;выведи "!истина = ложь"</code></p>
<p>Выведет:</p>
<p><code> a &gt; 40 a &lt;= б {действие после условия} !истина = ложь</code></p>
<h2 id="function">Функции</h2>
<p>Функция объявляется с помощью ключевого слова "функция" за которым следует список аргументов, а также тело самой функции. Выглядит это следующим образом:</p>
<p><code>функция {название}({аргумент1}, ...):<br /> &nbsp;&nbsp;&nbsp;&nbsp;{тело функции}<br /> &nbsp;&nbsp;&nbsp;&nbsp;{оператор верни}<br /> </code></p>
<p>Функция может не принимать аргументы, тогда список аргументов следует оставить пустым. Все команды в теле функции должны начинаться с табуляции. Функция может возвращать значение, тогда в ней должна быть команда "верни". Пример программы с использованием функций:</p>
<p><code>функция ПриветМир():<br />
&nbsp;&nbsp;&nbsp;&nbsp;верни "Hello World!"<br />
<br />
выведи ПриветМир<br />
<br />
функция Сумма(а, б):<br />
&nbsp;&nbsp;&nbsp;&nbsp;верни (+ а б)<br />
<br />
выведи Сумма 10 5<br />
<br />
функция Xor(x, y):<br />
&nbsp;&nbsp;&nbsp;&nbsp;если (= x y)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;тогда:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;верни ложь<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;иначе:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;верни истина<br />
<br />
выведи Xor истина ложь</code></p>

<p>Вывод программы:</p>
<p><code>Hello World! 15.000000 true </code></p>
<p>Функции могут быть рекурсивными. Примеры функций факториала, степени и печати чисел от x до y:</p>
<p><code>функция факториалРеализация(результат, н):<br />
&nbsp;&nbsp;&nbsp;&nbsp;если (| (= н 0) (= н 1))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;тогда:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;верни результат<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;иначе:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;верни факториалРеализация (* результат н) (- н 1)<br />
<br />
функция факториал(н):<br />
&nbsp;&nbsp;&nbsp;&nbsp;верни факториалРеализация 1 н<br />
<br />
выведи факториал 5<br />
<br />
<br />
функция печать(начало, конец):<br />
&nbsp;&nbsp;&nbsp;&nbsp;если (< начало конец)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;тогда:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;выведи начало<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;верни печать (+ 1 начало) конец<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;иначе:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;верни конец<br />
<br />
выведи печать 5 10<br />
<br />
<br />
функция степеньРеализация(x, sum, current, n):<br />
&nbsp;&nbsp;&nbsp;&nbsp;если (= current n)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;тогда:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;верни sum<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;иначе:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;верни степеньРеализация x (* x sum) (+ 1 current) n<br />
<br />
функция степень(x, n):<br />
&nbsp;&nbsp;&nbsp;&nbsp;верни степеньРеализация x 1 0 n<br />
<br />
выведи степень 2 10</code></p>
<p>
  Вывод программы:
</p>
<p>
  <code>
    120.000000 5.000000 6.000000 7.000000 8.000000 9.000000 10.000000 1024.000000
  </code>
</p>
</body>

</html>
