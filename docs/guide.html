<html>
<body>

<h1 id="guide">Руководство по языку #Ф</h1>
<h2 id="about">О языке</h2>
<p>В языке программирования #Ф реализованы следующие базовые функции, необходимые для работы - именованные переменные, рекурсия, ленивые вычисления, функции.</p>
<p>Подробнее о возможностях языка ниже.</p>
<h2 id="inside">Как и почему оно работает</h2>
<p>Наш язык интерпретируемый. Сам процесс исполнения программы состоит из 3 этапов: парсинг программы и её токенизация, построение синтаксического дерева программы и интерпретация.</p>
<p>Подробнее про синтаксис языка будет далее.</p>
<h3 id="parser">Парсер</h3>
<p>Парсер берёт текст программы и превращает его в последовательность токенов тем самым убирая все ненужные символы, оставляя только важную для программы информацию. На выходе он оставляет список токенов, каждый из которых является либо числом, либо командой, либо символами табуляции и новой строки.</p>
<p>Всего существует несколько типов лексем: операторы, слова идентификаторы, команды языка, и вспомогательные символы (скобки, табуляция, пробел, новая строка). Парсер последовательно читает текст программы символ за символом и в зависимости от прочитанного символа читает всю лексему. Например, если парсер считал число, то далее он будет ожидать на вход числа или пробел. В противном случае программа завершится с ошибкой.</p>
<p>Некоторые токены с их расшифровкой:</p>
<table style="height: 217px; width: 404px;">
<tbody>
<tr>
<td style="width: 106px;">Токен</td>
<td style="width: 186.388px;">Описание</td>
<td style="width: 91.6125px;">Пример</td>
</tr>
<tr>
<td style="width: 106px;">Number</td>
<td style="width: 186.388px;">Вещественное число</td>
<td style="width: 91.6125px;">5</td>
</tr>
<tr>
<td style="width: 106px;">Strings</td>
<td style="width: 186.388px;">Строка (значение)</td>
<td style="width: 91.6125px;">"aboba"</td>
</tr>
<tr>
<td style="width: 106px;">Operator</td>
<td style="width: 186.388px;">Операция</td>
<td style="width: 91.6125px;">+</td>
</tr>
<tr>
<td style="width: 106px;">FunctionDefinition</td>
<td style="width: 186.388px;">Определение новой функции</td>
<td style="width: 91.6125px;">функция</td>
</tr>
<tr>
<td style="width: 106px;">NewVariable</td>
<td style="width: 186.388px;">Определение новой переменной</td>
<td style="width: 91.6125px;">пусть</td>
</tr>
<tr>
<td style="width: 106px;">IfStatement</td>
<td style="width: 186.388px;">Условный оператор</td>
<td style="width: 91.6125px;">если</td>
</tr>
<tr>
<td style="width: 106px;">LeftRoundBracket</td>
<td style="width: 186.388px;">Открывающая круглая скобка</td>
<td style="width: 91.6125px;">(</td>
</tr>
<tr>
<td style="width: 106px;">Comma</td>
<td style="width: 186.388px;">Запятая</td>
<td style="width: 91.6125px;">,</td>
</tr>
<tr>
<td style="width: 106px;">Colon</td>
<td style="width: 186.388px;">двоеточие</td>
<td style="width: 91.6125px;">:</td>
</tr>
<tr>
<td style="width: 106px;">Identifier</td>
<td style="width: 186.388px;">Имя функции или переменной</td>
<td style="width: 91.6125px;">счётчик</td>
</tr>
</tbody>
</table>
<p>На этапе парсинга программы проверяется корректность всех введённых символов и слов.</p>
<h3 id="tree">Синтаксическое дерево</h3>
<p>Далее из последоватльности лексем собирается синтаксическое дерево программы, по которому она будет выполняться. Синтаксическое дерево представляет последовательность команд вместе с их аргументами в виде удобном для выполнения интерпретатором.&nbsp;</p>
<p>При построеннии синтаксического дерево мы линейно проходимся по списку лексем и пытаемся выделить из него отдельные команды, которые затем добавляем в список команд.</p>
<p>Пример некоторых элементов синтаксического дерева:</p>
<table style="height: 276px; width: 436px;">
<tbody>
<tr>
<td style="width: 108.65px;">OrdinaryList</td>
<td style="width: 311.35px;">Лист содержащий либо набор команд, либо набор аргументов</td>
</tr>
<tr>
<td style="width: 108.65px;">FunctionDefinition</td>
<td style="width: 311.35px;">Содержит имя функции, тело функции, количество аргументов функции и их список</td>
</tr>
<tr>
<td style="width: 108.65px;">
<div>
<div>IntroduceVariable</div>
</div>
</td>
<td style="width: 311.35px;">Содержит имя новой переменной и её начальное значение</td>
</tr>
<tr>
<td style="width: 108.65px;">OperatorNode</td>
<td style="width: 311.35px;">Оператор и список его аргументов</td>
</tr>
<tr>
<td style="width: 108.65px;">FuntionCall</td>
<td style="width: 311.35px;">Имя функции и список аргументов для её вызова</td>
</tr>
<tr>
<td style="width: 108.65px;">Condition</td>
<td style="width: 311.35px;">Булевый оператор условия и два списка команд для каждого из значений условия</td>
</tr>
<tr>
<td style="width: 108.65px;">Print</td>
<td style="width: 311.35px;">Список команд которые необходимо напечатать</td>
</tr>
<tr>
<td style="width: 108.65px;">Return</td>
<td style="width: 311.35px;">Список возвращаемых аргументов из функции</td>
</tr>
</tbody>
</table>
<p>На этом этапе проверяется правильность последовательности команд, например, то что функция верно определена. Также проверяется существование вызываемых функция и используемых переменных.</p>
<h3 id="interpreter">Интерпретатор</h3>
<p>Интерпретатор данного языка анализирует структуру синтаксического дерева и в зависимости от типов узлов производит соответствующие вычисления.</p>
<ul>
<li>Каждый раз новая вызванная функция или переменная проверяется на наличие в текущем окружении (было ли ее объявление перед этим вызовом). Если объявления не было, программа завершается с ошибкой</li>
<li>При объявлении переменной её значение не вычисляется сразу, а просто связывается с именем. Вычисление откладывается до того момента, пока эта переменная не потребуется в программе (ленивые вычисления)</li>
<li>При интерпретации условного выражения сначала вычисляется условие, а затем соответствующая этому условию ветвь</li>
<li>При вызове функции проверяется соответствие количества аргументов объявленной и вызываемой функции. Затем аргументы функции связываются с параметрами вызова, и вместе с сохраненным окружением используются для интерпретации тела функции. В этом процессе также учитывается информация о самой функции, что позволяет осуществлять рекурсивные вызовы функций</li>
<li>При выполнении различных выражений с операторами сначала проверяется соответсвие типов операндов. При несоответствии возвращается сообщение об ошибке</li>
<li>Если необходимо интерпретировать тип OrdinaryList, то сначала интерпретируются все его подвыражения</li>
<li>Интерпретатор возращает один из подтипов SyntaxNode</li>
</ul>
<h2 id="variables">Переменные</h2>
<p>Чтобы создать именованную переменную в языке #Ф используется следующая конструкция:</p>
<p><code> пусть {название переменной} = {начальное значение}</code></p>
<p>Переменная не может менять своё значение, которое может быть одним из нескольких типов:</p>
<table style="height: 66px; width: 292.3px;">
<tbody>
<tr>
<td style="width: 98px;">Тип переменной</td>
<td style="width: 179.3px;">Значение</td>
</tr>
<tr>
<td style="width: 98px;">строка</td>
<td style="width: 179.3px;">последовательность символов</td>
</tr>
<tr>
<td style="width: 98px;">число</td>
<td style="width: 179.3px;">дробное число</td>
</tr>
<tr>
<td style="width: 98px;">булевый тип</td>
<td style="width: 179.3px;">истина/ложь</td>
</tr>
</tbody>
</table>
<p>Например программа:</p>
<p><code> пусть а = "Hello world!"<br /> пусть б = 5 <br /> пусть в = истина <br /> выведи а б в</code></p>
<p>Выведет:</p>
<p><code> Hello world! 5.340000 true</code></p>
</body>

</html>
